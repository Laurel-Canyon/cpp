# 高程

联合：用一种类型的数据表示多种类型的数据

## 数据抽象与封装

抽象：控制复杂度，呈现外部可观察行为，不考虑内部实现；对特征的描述

封装：信息保护，隐藏内部实现，只提供接口

> 抽象与封装的区别：https://www.zhihu.com/question/20266563

* 过程抽象与封装：子程序，将执行过程抽象成为一个函数名，通过参数机制和返回值机制实现接口（函数）
* 数据抽象与封装：隐藏数据的具体表示，只呈现数据支持的操作和操作之间的关系，将操作作为接口对外呈现，`能够更好地实现数据保护`

利用全局变量进行函数交互有什么缺点？（数据公开，缺乏保护）

计算机语言函数会产生副作用

## 面向对象程序设计概述

对象是由一些数据和在数据上的操作构成的封装体，对象特征由类描述，对数据的操作是由向包含该数据的对象发送消息实现的；有同步消息处理和异步消息处理之分。

类属于`类型`，是编译过程的实体；对象属于`值`，是程序运行时刻的实体。

继承

多态

> 函数不会通过返回值类型区别重载

绑定

## 对象和类

类：成员包括数据成员和成员函数，类成员标识符的作用域是整个类定义

>  void类型主要用于无返回值的函数以及构造指向任意指针的指针类型

在c++旧标准中，定义类时没有为类成员分配内存空间，故不可在定义类型时对其进行初始化；如果数据成员涉及未定义的类或者未完成定义的类，只能定义其`指针或引用`类型。

> 构造的对象作为引用类型传入返回值为非引用类型的函数的问题，会构造一个临时变量作为返回值，对该返回值进行修改不会影响原来的对象，详情请见ppt2-1第19页

### 数据成员

```c++
class A;
class B
{
    A a;	//error
    B b;	//error
    A *p;
    B *q;
    A &aa;
    B &bb;
}
```

### 类成员函数的定义

* 类内定义：建议编译器按照`内联函数`处理，在调用时直接将函数定义展开到调用点，兼具宏定义和函数的优点，方便频繁使用的小函数的调用，但是无法处理`递归函数`等；
* 类外定义：需要添加`<类名>::`进行限制。

结构体和联合体也被允许定义函数，但是与类的区别是访问控制不同，默认为`public`，而类默认为`private`。

### 访问控制

public private protected

### 对象的创建

直接创建和间接创建

间接方式是利用`new`创建，利用`delete`进行删除，不采用`malloc`和`free`进行操作，因为`malloc`只进行内存分配，不调用构造函数进行初始化等操作；`free`也不会调用析构函数。

```c++
class A
{
public:
    A();
    A(int i);
    A(char *p);
}
A a1;			//调用默认构造函数，亦作：A a1 = A();
A a2(1);		//调用A(int i)，亦作：A a2 = 1;
A a3("abcd");	//调用A("abcd")，亦作：A a3 = "abcd";
A b0[5] = {A(), A(1), A("abcd"), 2, "xyz"};
A *p1 = new A();
A *p2 = new A(2);
A *p3 = new A("abcd");
A *p4 = new A[10];	//创建动态对象数组时只能调用默认构造函数
```

### this指针

每个成员函数一般都有一个隐藏的形参this，为`<类名> *const this`，在成员函数中对类成员的访问是通过`this`来进行的。

```c++
void A::g(int i)	{	x = i;	}
->
void A::g(A *const this, int i)	{	this -> x = i;	}
```

通常情况下，访问类成员时`this->`可以省略不写，编译器会自动添加；如果需要用到`this`所指向的对象的话，也可以显式地调用。

结构体和联合体的成员函数在对成员进行操作的时候，需要显式地调用`this`。

### 构造函数

在对象类中定义或声明的与类同名、无返回值类型的成员函数，当创建对象时，会自动调用构造函数。对象被创建之后就不能再调用构造函数了。

构造函数也可以重载，不带参数（或所有参数都有默认值的）构造函数被称为`默认构造函数`。

如果未提供构造函数，则编译器会隐式地提供一个默认构造函数，但编译器不会为含有常量或引用类型数据成员的类提供默认构造函数（不会对这些成员初始化）。

类的构造函数一般是`public`，但是有时候也将其声明为`private`，此时只能在本类和友元中创建该类对象。

可以利用构造函数创建一个`临时对象`，将其赋值给特定对象，在计算表达式完成后，临时对象就会消亡。

> https://www.cnblogs.com/mengwang024/p/4292276.html

### 成员初始化表

```c++
class A
{
    int x;
    const int y;
    int& z;
public:
    A():	x(0), z(x), y(1)
}
```

成员初始化的书写顺序并不决定它们的初始化顺序，数据成员的初始化顺序由`它们在类定义中的说明顺序`来决定。

> https://blog.csdn.net/liushunCSDNblog/article/details/82715539

### 析构函数

一般来说，自定义析构函数以归还对象`额外申请`的内存空间。

析构函数可以显式地调用，暂时归还对象所申请的额外资源，如调用`string`类的析构函数清空字符串，调用`stack`类的析构函数清空栈。

### 成员对象初始化和消亡处理

创建一个对象时，如果它包含成员对象，那么会先调用成员对象的构造函数（如果有多个成员对象，那么调用构造函数的次序是`按照在本对象类中的声明顺序进行`），如无特别说明，调用的是默认构造函数；如果要调用非默认构造函数，那么需要在包含这些成员对象的对象类的构造函数成员初始化表中显式指出。

对象消亡时，先调用本身类的析构函数，再调用成员对象的析构函数（若有多个成员对象，那么调用次序是按照在本对象类中的声明`逆序`进行）。

如果本身未定义析构函数，但是包含成员对象，那么编译器会隐式给出析构函数，其作用即调用成员对象的析构函数。

